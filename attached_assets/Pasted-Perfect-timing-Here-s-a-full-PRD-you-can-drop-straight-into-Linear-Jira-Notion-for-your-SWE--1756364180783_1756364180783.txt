Perfect timing ğŸ‘ Hereâ€™s a **full PRD** you can drop straight into Linear/Jira/Notion for your SWE. Itâ€™s written like a proper **Product Requirements Document** with scope, flow, API contracts, and acceptance criteria. This will let your engineer integrate **Gemini AI** into **Unfollowr** (Instagram non-follower analyzer).

---

# ğŸ“„ Product Requirements Document (PRD)

**Feature:** AI-powered Segmentation & Chatbot
**Product:** Unfollowr (Instagram Non-Follower Analyzer)
**Date:** 2025-08-27
**Owner:** \[You]
**Engineering:** \[Senior SWE]
**AI:** Google Gemini API (1.5 Flash)

---

## 1. Problem Statement

Unfollowr currently identifies accounts that a user follows but who donâ€™t follow back. This works, but users still face **decision fatigue**: *â€œWho should I actually unfollow?â€*
We want to integrate **AI classification + a chatbot assistant** so users can quickly understand their following list, get recommendations, and interact in natural language.

---

## 2. Goals & Objectives

* Enrich follower/following data with **AI-powered segments** (e.g., Celebrity, Creator, Friend, Spam).
* Provide **reasons/explanations** for suggestions (transparent AI).
* Add a **chatbot interface** so users can filter and query their data in plain English.
* Keep costs low: free-tier friendly using **heuristics-first, LLM-assist if ambiguous**.
* Maintain privacy: all processing stays local or within Unfollowr servers (no external Instagram API calls).

---

## 3. Non-Goals

* Real-time Instagram API lookups (blocked by Meta).
* Persistent user history (v1 = session-only).
* Recommendation personalization beyond provided data (no behavioral tracking).

---

## 4. User Stories

1. **As a user**, I want to upload my export and see accounts grouped into meaningful categories (e.g., â€œCelebritiesâ€, â€œLikely Friendsâ€).
2. **As a user**, I want to see *why* someone is suggested for unfollow (e.g., â€œDoesnâ€™t follow you backâ€ + â€œSpammy keywordsâ€).
3. **As a user**, I want to ask: *â€œHide celebrities and brandsâ€* and instantly filter my list.
4. **As a user**, I want the chatbot to answer: *â€œWho are my real friends that donâ€™t follow back?â€*
5. **As a user**, I want the app to work smoothly without hitting AI limits, so it feels reliable.

---

## 5. Proposed Solution

### 5.1 Data Pipeline

1. User uploads Instagram export.
2. Normalize to `Account` object:

   ```ts
   type Account = {
     username: string;
     fullName?: string;
     bio?: string;
     followersCount?: number;
     followingCount?: number;
     nonFollower?: boolean;
     segment?: "celebrity"|"creator"|"brand"|"friend"|"spam"|"unknown";
     suggestionScore?: number;
     explanations?: string[];
   }
   ```
3. Run **Heuristic Classifier** â†’ label most accounts offline.
4. Send **ambiguous accounts** (no strong signal) to **Gemini 1.5 Flash** for classification.
5. Merge results â†’ output enriched list.

---

### 5.2 Segmentation

Segments:

* **Celebrity / Brand** (e.g., verified, big accounts, brand terms)
* **Creator** (artist, fitness, influencer keywords)
* **Friend (Real Person)** (real name, low follower count, private)
* **Spam** (giveaway/crypto/forex keywords, emoji soup)
* **Unknown** (unclassified)

Each account gets:

* **Segment label**
* **Confidence score**
* **Explanations** (short reasons)

---

### 5.3 Suggestion Score

* Weighted algorithm:

  * Non-follower = +0.6
  * Celeb/Brand/Creator = +0.3
  * Spam = +0.5
  * Friend = âˆ’0.7 (protect real people)
* Renders â€œSuggested unfollowsâ€ list sorted by score.

---

### 5.4 Chatbot

* UI: floating chat bubble â†’ opens side panel.
* Prompts â†’ sent to **Gemini API** (`/api/ai/translate-query`).
* Gemini returns **structured filter JSON**:

  ```json
  {
    "segments": ["celebrity","brand"],
    "minSuggestion": 0.6,
    "hideFollowers": true
  }
  ```
* Frontend applies filters to the local dataset.
* Responses show counts + reason summaries.

Example UX:

* User: *â€œHide celebrities and brandsâ€* â†’ list updates instantly.
* User: *â€œShow me real friends who donâ€™t follow backâ€* â†’ filter: `{segments:["friend"], hideFollowers:true}`.

---

### 5.5 AI Integration (Gemini)

* **Model:** `gemini-1.5-flash`
* **Temperature:** `0` (deterministic, reproducible)
* **Mode:** JSON-only responses (`responseMimeType: application/json`)
* **Batch size:** â‰¤50 accounts per call
* **Endpoints:**

  * `/api/ai/classify-batch` â†’ classify ambiguous accounts
  * `/api/ai/translate-query` â†’ convert NL â†’ filter JSON

---

## 6. UX Requirements

* Upload flow unchanged.
* New **Segment filter bar** above results (toggle chips).
* **Suggested unfollows tab** with reasons shown per account.
* Chatbot accessible from a **chat bubble** in bottom right.
* Loading states: show â€œAI is enriching resultsâ€¦â€ spinner after upload.
* Errors: fallback to heuristics if API fails.

---

## 7. Technical Requirements

### Frontend

* Next.js + Tailwind
* Components: `<UploadCard />`, `<Reveal />`, `<Chatbot />`, `<AccountList />`
* State: React context or Zustand store for account list

### Backend

* Node API routes under `/api/ai/*`
* Integrate Google Gemini via `@google/generative-ai`
* Hide API key on server only
* Add simple rate limiting (1 batch per session)

### Data Flow

1. Upload â†’ parse â†’ local `Account[]`.
2. Run heuristics â†’ mark ambiguous.
3. Call `/api/ai/classify-batch` â†’ merge results.
4. Store enriched list in memory.
5. Chatbot queries â†’ `/api/ai/translate-query` â†’ apply filters.

---

## 8. Security & Privacy

* Files processed client-side; only ambiguous bios/names sent to Gemini.
* No data stored server-side; ephemeral session only.
* Obfuscate usernames before LLM call if needed (`id:hash(username)`).
* Always sanitize bios to remove slurs before showing.

---

## 9. Success Metrics

* â‰¥80% of accounts classified into meaningful segments.
* Users can filter via chatbot with â‰¥90% accuracy to intent.
* AI API calls per session â‰¤1â€“2 (cost-controlled).
* Lighthouse Perf â‰¥90, CLS <0.05 maintained.

---

## 10. Acceptance Criteria

* âœ… Upload produces enriched list with segment chips.
* âœ… â€œSuggested unfollowsâ€ tab sorted by score, each row has explanation.
* âœ… Chatbot responds to at least 5 core queries:

  1. Hide celebrities
  2. Show only friends
  3. Show spam accounts
  4. Show non-followers only
  5. Show real friends who donâ€™t follow back
* âœ… If Gemini quota is hit, fallback = heuristic only (no crash).
* âœ… All outputs are valid JSON (no malformed responses).
* âœ… Accessibility: chat and filters usable by keyboard & screen readers.

---

## 11. Open Questions

* Do we obfuscate usernames before sending to Gemini (privacy vs UX tradeoff)?
* Do we persist filters/selections across sessions (localStorage)?

---

## 12. Timeline

* **Week 1:** Implement heuristics + segment chips.
* **Week 2:** Add Gemini classify-batch endpoint + merge.
* **Week 3:** Add chatbot endpoint + frontend chat panel.
* **Week 4:** QA, perf testing, ship.

---

âœ… This gives your SWE everything needed: **data contract, endpoints, UX, AI prompts, fallback rules, acceptance criteria.**

---

Do you want me to also draft the **exact Gemini prompts** (system + user templates) for both *classify-batch* and *translate-query* so your SWE can copy them straight into the code?
